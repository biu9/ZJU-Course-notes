# 二叉树

---

> 定义：1、是有序树
>
> ​			2、树中各个节点的度不超过2

> 推论：若树有n个结点，则它有2n个指针域，有n+1个已使用的指针域，n-1个空指针域

> degree:度，结点的度指的是结点拥有的子树的数目，整棵树的度指的是树中结点的最大的度
>
> 叶子结点：一棵树当中没有子结点（度为0）的结点称为叶子结点
>
> 在一棵树中，结点总数=度数*该度数对应的结点+1
>
> 树的度指树中结点的度的最大值



### 普通树转二叉树

---

> `左儿子，右兄弟`
>
> 实现步骤：
>
> > 1、将树的根结点作为二叉树的根结点
> >
> > 2、将树的根结点的第一个子结点作为根结点的左儿子，若该子结点存在兄弟结点，则将孩子的第一个兄弟结点（方向从左往右）作为该子结点的右儿子
> >
> > 3、将剩余结点按上一步一次添加到二叉树中

![image-20211115224400591](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211115224400591.png)

### 满二叉树

---

> 定义：一颗深度为h且有2^h-1个结点的二叉树

> 性质：1、若叶子结点有n个则总结点数为2n-1
>
> ​			2、若结点有n个，则树高为$\log_2{n}+1$



### 完全二叉树

---

> 定义：高度为h的一棵树，除了第h层以外，其他2-（h-1）层都达到最大结点数，第h层从右往左			缺失若干个结点

> 性质：1、若结点有n个，则树高为$\log_2{n}+1$
>
> ​			2、若树高为h，则总结点数n<=$2^h$-1
>
> ​			3、若树的深度为k，则第k层有$2^{k-1}$个结点
>
> ​			4、若结点有n个，则叶子结点有n/2个

完全二叉树的最大的优点是可以通过父（子）结点编号求得子（父）结点编号



### 二叉树的数组实现

---

<img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211013151541408.png" alt="image-20211013151541408" style="zoom: 80%;" />

##### 法1

> 给定一个数组a[MAXSIZE],若父结点为a[k],则其左子节点为a[2k],右子结点为a[2k+1]
>
> 可以推导出，深度为n的第一个结点的左子节点为a[$2^n*k$],另一个右字节结点为a[$2^n*k+1$]



### 二叉树的链表实现

---





### 二叉树的遍历

---

> 先序遍历：考察到一个节点以后，输出该节点的值，并继续遍历其左右子树（先左后右）
>
> ```c
> void reorder(tree_ptr tree){
>     if(tree){
>         visit(tree);
>         for(each child c of tree)
>             	preorder(c);
>     }
> }
> ```
>
---

> 中序遍历：考察到一个节点以后，将其暂存，遍历完左子树后再输出该节点的值，然后遍历右子树
>
> ```c
> void inorder(tree_ptr tree){
>     if(tree){
>         inorder(tree->left);
>         visit(tree->element);
>         inorder(tree->right);
>     }
> }
> ```
>
---

> 后序遍历：考察到一个子节点后，将其暂存，遍历完左右子树，再输出左右子树的值
>
> ```c
> void postorder(tree_ptr tree){
>     if(tree){
>         for(each child c of tree)
>             	postorder(c);
>         visit(tree);
>     }
> }
> ```
---

<img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211015211959129.png" alt="image-20211015211959129" style="zoom: 50%;" />

### 二叉树的插入

---

​	将要插入结点的键值与根结点键值比较，如果小于根结点键值，则插入根结点的左子树，如果大于根结点的键值，则插入根结点的右子树

### 线索二叉树

---

​	对于一个有n个结点的二叉树而言，一共会有n+1个空指针

​	遍历二叉树的实质是将二叉树中非线性结构的结点转化为线性的序列

##### 线索化的总思路

​	如果访问到当前结点的时候，线索化其左子树并记录下上一个访问的结点，再对上一个访问的结点的右子树进行线索化，直到所有结点都访问完

##### 线索化中序二叉树

​	将所有原本为空的右孩子指针指向该节点在中序序列中的后继，所有原本为空的左孩子指针指向该节点在中序序列中的前驱

![image-20211115225414839](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211115225414839.png)



### 二叉查找树

---

​	binary search tree，是一种特殊的二叉树，改善了二叉树结点查找的效率，二叉查找树有以下性质：

对于任意一个结点n，

 - 其左子树下的每个后代结点的值都小于等于结点n的值
 - 其右子树下的每个后代节点的值都大于等于结点n的值
 - 若n的左子树不空，则左子树上所有结点的值均不大于它的根结点的值
 - 若n的右子树不空，则右子树上所有结点的值均不小于它的根结点的值
 - n的左右子树也分别为二叉搜索树

##### 复杂度

​	如果有n个元素，平均每次操作需要O(log n)的时间

##### 创建搜索二叉树

​	给出一组元素，创建时，把第一个元素作为根结点，把下一个元素与根结点比较，根据大小放到对应的子树中

##### 删除搜索二叉树结点

​	当该结点既有左子树又有右子树时，有两种删除办法：

 1. 找到左子树上最大的上去
 	2. 找到右子树上最小的上去
